
"use server"; // Can be used in Server Actions or API routes if needed, but primarily for client-side calls here

import { db } from '@/lib/firebase';
import { collection, query, where, getDocs, addDoc, doc, getDoc, setDoc, updateDoc, deleteDoc, Timestamp } from 'firebase/firestore';
import type { User } from '@/types';

const USERS_COLLECTION = 'users';

/**
 * Fetches a user profile from Firestore by email.
 * @param email The user's email.
 * @returns The user data if found, otherwise null.
 */
export async function getUserByEmail(email: string): Promise<User | null> {
  try {
    const usersRef = collection(db, USERS_COLLECTION);
    const q = query(usersRef, where('email_id', '==', email));
    const querySnapshot = await getDocs(q);

    if (!querySnapshot.empty) {
      // Assuming email is unique, so take the first doc
      const userDoc = querySnapshot.docs[0];
      return { id: userDoc.id, ...userDoc.data() } as User;
    }
    return null;
  } catch (error: any) {
    console.error("Error fetching user by email:", error);
    const message = error instanceof Error ? error.message : String(error);
    throw new Error(`Failed to fetch user by email: ${message}`);
  }
}

/**
 * Fetches a user profile from Firestore by ID.
 * @param userId The user's Firestore document ID.
 * @returns The user data if found, otherwise null.
 */
export async function getUserById(userId: string): Promise<User | null> {
  try {
    const userDocRef = doc(db, USERS_COLLECTION, userId);
    const userDocSnap = await getDoc(userDocRef);

    if (userDocSnap.exists()) {
      return { id: userDocSnap.id, ...userDocSnap.data() } as User;
    }
    return null;
  } catch (error: any) {
    console.error("Error fetching user by ID:", error);
    const message = error instanceof Error ? error.message : String(error);
    throw new Error(`Failed to fetch user by ID: ${message}`);
  }
}


/**
 * Creates a new user profile in Firestore.
 * The ID will be auto-generated by Firestore.
 * @param userData Partial user data (email_id is required).
 * @returns The created user data including its new Firestore ID.
 */
export async function createUser(userData: Omit<User, 'id' | 'joined_date'> & { joined_date?: Timestamp }): Promise<User> {
  try {
    const userToCreate = {
      ...userData,
      joined_date: Timestamp.now().toDate().toISOString(),
    };
    const docRef = await addDoc(collection(db, USERS_COLLECTION), userToCreate);
    return { ...userToCreate, id: docRef.id } as User;
  } catch (error: any) {
    console.error("Error creating user:", error);
    const message = error instanceof Error ? error.message : String(error);
    throw new Error(`Failed to create user: ${message}`);
  }
}

/**
 * Updates an existing user profile in Firestore.
 * @param userId The Firestore document ID of the user.
 * @param userData Partial user data to update.
 */
export async function updateUser(userId: string, userData: Partial<Omit<User, 'id'>>): Promise<void> {
  try {
    const userDocRef = doc(db, USERS_COLLECTION, userId);
    await updateDoc(userDocRef, userData);
  } catch (error: any) {
    console.error("Error updating user:", error);
    const message = error instanceof Error ? error.message : String(error);
    throw new Error(`Failed to update user: ${message}`);
  }
}

/**
 * Deletes a user profile from Firestore.
 * @param userId The Firestore document ID of the user.
 */
export async function deleteUser(userId: string): Promise<void> {
  try {
    const userDocRef = doc(db, USERS_COLLECTION, userId);
    await deleteDoc(userDocRef);
    // Note: This does not delete subcollections. If users have subcollections (e.g., trackedApplications),
    // those would need to be deleted separately, often with a Firebase Function for thoroughness.
  } catch (error: any) {
    console.error("Error deleting user:", error);
    const message = error instanceof Error ? error.message : String(error);
    throw new Error(`Failed to delete user: ${message}`);
  }
}
